{"version":3,"sources":["../../src/swc/dir.ts"],"sourcesContent":["import { existsSync, promises } from \"fs\";\nimport { dirname, resolve } from \"path\";\nimport Piscina from \"piscina\";\nimport { CompileStatus } from \"./constants\";\nimport { CliOptions } from \"./options\";\nimport { exists, getDest } from \"./util\";\nimport handleCompile from \"./dirWorker\";\nimport {\n  globSources,\n  isCompilableExtension,\n  splitCompilableAndCopyable,\n  watchSources,\n} from \"./sources\";\n\nimport type { Options } from \"@swc/core\";\n\ndeclare module \"fs\" {\n  namespace promises {\n    /**\n     * For node > 14 we want to use rm instead of rmdir\n     * We need to augment node v12 types\n     */\n    function rm(dir: string, option: object): void;\n  }\n}\n\nconst { mkdir, rmdir, rm, copyFile, unlink } = promises;\n\nconst recursive = { recursive: true };\n\nasync function handleCopy(\n  filename: string,\n  outDir: string,\n  stripLeadingPaths: boolean\n) {\n  const dest = getDest(filename, outDir, stripLeadingPaths);\n  const dir = dirname(dest);\n\n  await mkdir(dir, recursive);\n  await copyFile(filename, dest);\n\n  return CompileStatus.Copied;\n}\n\nasync function beforeStartCompilation(cliOptions: CliOptions) {\n  const { outDir, deleteDirOnStart } = cliOptions;\n\n  if (deleteDirOnStart) {\n    const exists = await existsSync(outDir);\n    if (exists) {\n      rm ? await rm(outDir, recursive) : await rmdir(outDir, recursive);\n    }\n  }\n}\n\nasync function initialCompilation(cliOptions: CliOptions, swcOptions: Options) {\n  const {\n    includeDotfiles,\n    filenames,\n    copyFiles,\n    extensions,\n    outDir,\n    outFileExtension,\n    stripLeadingPaths,\n    sync,\n    quiet,\n    watch,\n    only,\n    ignore,\n  } = cliOptions;\n\n  const results = new Map<string, CompileStatus>();\n\n  const start = process.hrtime();\n  const sourceFiles = await globSources(\n    filenames,\n    only,\n    ignore,\n    includeDotfiles\n  );\n  const [compilable, copyable] = splitCompilableAndCopyable(\n    sourceFiles,\n    extensions,\n    copyFiles\n  );\n\n  if (sync) {\n    for (const filename of compilable) {\n      try {\n        const result = await handleCompile({\n          filename,\n          outDir,\n          sync,\n          cliOptions,\n          swcOptions,\n          outFileExtension,\n        });\n        results.set(filename, result);\n      } catch (err: any) {\n        console.error(err.message);\n        results.set(filename, CompileStatus.Failed);\n      }\n    }\n    for (const filename of copyable) {\n      try {\n        const result = await handleCopy(filename, outDir, stripLeadingPaths);\n        results.set(filename, result);\n      } catch (err: any) {\n        console.error(err.message);\n        results.set(filename, CompileStatus.Failed);\n      }\n    }\n  } else {\n    const workers = new Piscina({\n      filename: resolve(__dirname, \"./dirWorker.js\"),\n      maxThreads: cliOptions.workers,\n      concurrentTasksPerWorker: 2,\n    });\n\n    await Promise.all([\n      Promise.allSettled(\n        compilable.map(filename =>\n          workers\n            .run({\n              filename,\n              outDir,\n              sync,\n              cliOptions,\n              swcOptions,\n              outFileExtension,\n            })\n            .catch(err => {\n              console.error(err.message);\n              throw err;\n            })\n        )\n      ),\n      Promise.allSettled(\n        copyable.map(file => handleCopy(file, outDir, stripLeadingPaths))\n      ),\n    ]).then(([compiled, copied]) => {\n      compiled.forEach((result, index) => {\n        const filename = compilable[index];\n        if (result.status === \"fulfilled\") {\n          results.set(filename, result.value);\n        } else {\n          results.set(filename, CompileStatus.Failed);\n        }\n      });\n\n      copied.forEach((result, index) => {\n        const filename = copyable[index];\n        if (result.status === \"fulfilled\") {\n          results.set(filename, result.value);\n        } else {\n          results.set(filename, CompileStatus.Failed);\n        }\n      });\n    });\n  }\n  const end = process.hrtime(start);\n\n  let failed = 0;\n  let compiled = 0;\n  let copied = 0;\n  for (let [_, status] of results) {\n    switch (status) {\n      case CompileStatus.Compiled:\n        compiled += 1;\n        break;\n      case CompileStatus.Failed:\n        failed += 1;\n        break;\n      case CompileStatus.Copied:\n        copied += 1;\n        break;\n    }\n  }\n\n  if (!quiet && compiled + copied) {\n    let message = \"\";\n    if (compiled) {\n      message += `Successfully compiled: ${compiled} ${\n        compiled > 1 ? \"files\" : \"file\"\n      }`;\n    }\n    if (compiled && copied) {\n      message += \", \";\n    }\n    if (copied) {\n      message += `copied ${copied} ${copied > 1 ? \"files\" : \"file\"}`;\n    }\n    message += ` with swc (%dms)`;\n\n    console.log(message, (end[1] / 1000000).toFixed(2));\n  }\n\n  if (failed) {\n    console.log(\n      `Failed to compile ${failed} ${failed !== 1 ? \"files\" : \"file\"} with swc.`\n    );\n    if (!watch) {\n      const files = Array.from(results.entries())\n        .filter(([, status]) => status === CompileStatus.Failed)\n        .map(([filename, _]) => filename)\n        .join(\"\\n\");\n      throw new Error(`Failed to compile:\\n${files}`);\n    }\n  }\n}\n\nasync function watchCompilation(cliOptions: CliOptions, swcOptions: Options) {\n  const {\n    includeDotfiles,\n    filenames,\n    copyFiles,\n    extensions,\n    outDir,\n    stripLeadingPaths,\n    outFileExtension,\n    quiet,\n    sync,\n  } = cliOptions;\n\n  const watcher = await watchSources(filenames, includeDotfiles);\n  watcher.on(\"ready\", () => {\n    if (!quiet) {\n      console.info(\"Watching for file changes.\");\n    }\n  });\n  watcher.on(\"unlink\", async filename => {\n    try {\n      if (isCompilableExtension(filename, extensions)) {\n        await unlink(getDest(filename, outDir, stripLeadingPaths, \".js\"));\n        const sourcemapPath = getDest(\n          filename,\n          outDir,\n          stripLeadingPaths,\n          \".js.map\"\n        );\n        const sourcemapExists = await exists(sourcemapPath);\n        if (sourcemapExists) {\n          await unlink(sourcemapPath);\n        }\n      } else if (copyFiles) {\n        await unlink(getDest(filename, outDir, stripLeadingPaths));\n      }\n    } catch (err: any) {\n      if (err.code !== \"ENOENT\") {\n        console.error(err.stack);\n      }\n    }\n  });\n  for (const type of [\"add\", \"change\"]) {\n    watcher.on(type, async filename => {\n      if (isCompilableExtension(filename, extensions)) {\n        try {\n          const start = process.hrtime();\n          const result = await handleCompile({\n            filename,\n            outDir,\n            sync,\n            cliOptions,\n            swcOptions,\n            outFileExtension,\n          });\n          if (!quiet && result === CompileStatus.Compiled) {\n            const end = process.hrtime(start);\n            console.log(\n              `Successfully compiled ${filename} with swc (%dms)`,\n              (end[1] / 1000000).toFixed(2)\n            );\n          }\n        } catch (err: any) {\n          console.error(err.message);\n        }\n      } else if (copyFiles) {\n        try {\n          const start = process.hrtime();\n          const result = await handleCopy(filename, outDir, stripLeadingPaths);\n          if (!quiet && result === CompileStatus.Copied) {\n            const end = process.hrtime(start);\n            console.log(\n              `Successfully copied ${filename} with swc (%dms)`,\n              (end[1] / 1000000).toFixed(2)\n            );\n          }\n        } catch (err: any) {\n          console.error(`Failed to copy ${filename}`);\n          console.error(err.message);\n        }\n      }\n    });\n  }\n}\n\nexport default async function dir({\n  cliOptions,\n  swcOptions,\n}: {\n  cliOptions: CliOptions;\n  swcOptions: Options;\n}) {\n  const { watch } = cliOptions;\n\n  await beforeStartCompilation(cliOptions);\n  await initialCompilation(cliOptions, swcOptions);\n\n  if (watch) {\n    await watchCompilation(cliOptions, swcOptions);\n  }\n}\n"],"names":["dir","mkdir","rmdir","rm","copyFile","unlink","promises","recursive","handleCopy","filename","outDir","stripLeadingPaths","dest","getDest","dirname","CompileStatus","Copied","beforeStartCompilation","cliOptions","deleteDirOnStart","exists","existsSync","initialCompilation","swcOptions","includeDotfiles","filenames","copyFiles","extensions","outFileExtension","sync","quiet","watch","only","ignore","results","Map","start","process","hrtime","sourceFiles","globSources","compilable","copyable","splitCompilableAndCopyable","result","handleCompile","set","err","console","error","message","Failed","workers","Piscina","resolve","__dirname","maxThreads","concurrentTasksPerWorker","Promise","all","allSettled","map","run","catch","file","then","compiled","copied","forEach","index","status","value","end","failed","_","Compiled","log","toFixed","files","Array","from","entries","filter","join","Error","watchCompilation","watcher","watchSources","on","info","isCompilableExtension","sourcemapPath","sourcemapExists","code","stack","type"],"mappings":"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"}